/*
Type for YYSTYPE
*/

%union {
	struct decl *decl;
	struct stmt *stmt;
	struct expr *expr;
	struct type *type;
	struct param_list *param_list;
	char *name;
};

/*
YYSTYPE for each type of production
*/
%start program
%type <decl> program decl_list decl
%type <type> type
%type <param_list> param_list param_list_not_empty param
%type <name> ident
%type <stmt> stmt_list stmt stmt_matched stmt_unmatched stmt_block
%type <expr> expr expr_no_or expr_no_and expr_no_cmp expr_no_arith expr_no_geo expr_no_unary expr_no_exp expr_primary opt_expr expr_list expr_list_not_empty expr_group expr_no_assign expr_block expr_list_not_empty_b /* expr_array_list */

%left TOKEN_ADD TOKEN_SUBTRACT
%left TOKEN_MULT TOKEN_DIV TOKEN_MOD
/*
Token types
*/
%token TOKEN_ERROR
%token TOKEN_IDENT
%token TOKEN_STRING_LITERAL
%token TOKEN_INTEGER_LITERAL
%token TOKEN_CHARACTER_LITERAL
%token TOKEN_ARRAY
%token TOKEN_BOOLEAN
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FUNCTION
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_ADD
%token TOKEN_SUB
%token TOKEN_MUL
%token TOKEN_DIV
%token TOKEN_MOD
%token TOKEN_EXP
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_GT
%token TOKEN_GE
%token TOKEN_LT
%token TOKEN_LE
%token TOKEN_EQ
%token TOKEN_NE
%token TOKEN_ASSIGN
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_COLON
%token TOKEN_SEMICOLON
%token TOKEN_L_PAREN
%token TOKEN_R_PAREN
%token TOKEN_L_BRACE
%token TOKEN_R_BRACE
%token TOKEN_L_BRACKET
%token TOKEN_R_BRACKET
%token TOKEN_COMMA
%token TOKEN_LOGICAL_NOT

%{
#include "token.h"
#include <stdio.h>
#include "expr.h"
#include "stmt.h"
#include "param_list.h"
#include "decl.h"
#include "type.h"
#include "symbol.h"
#include "hash_table.h"
#include "scope.h"


/*
Manually declare the interface to the scanner generated by flex.
*/

extern char *yytext;
extern int yylex();
extern int yyerror(char *str);

struct decl * program = 0;
%}

%%

program			: decl_list {program = $1;}
			;
decl_list		: decl decl_list {$$ = $1; $1->next=$2;}
			| {$$ = 0;}
			;
decl			: ident TOKEN_COLON type TOKEN_ASSIGN expr TOKEN_SEMICOLON {$$ = decl_create($1,$3,$5,0,0);}
			| ident TOKEN_COLON type TOKEN_SEMICOLON {$$ = decl_create($1,$3,0,0,0);}
			| ident TOKEN_COLON type TOKEN_ASSIGN TOKEN_L_BRACE stmt_list TOKEN_R_BRACE {$$ = decl_create($1,$3,0,$6,0); if(!$6) {$$->code=stmt_create(STMT_EMPTY,0,0,0,0,0,0);};}
			| ident TOKEN_COLON type TOKEN_ASSIGN TOKEN_L_BRACE expr_list_not_empty_b TOKEN_R_BRACE TOKEN_SEMICOLON {$$ = decl_create($1,$3,$6,0,0);}
			;
type			: TOKEN_STRING {$$ = type_create(TYPE_STRING,0,0);}
			| TOKEN_INTEGER {$$ = type_create(TYPE_INTEGER,0,0);}
			| TOKEN_CHAR {$$ = type_create(TYPE_CHARACTER,0,0);}
			| TOKEN_BOOLEAN {$$ = type_create(TYPE_BOOLEAN,0,0);}
			| TOKEN_ARRAY TOKEN_L_BRACKET opt_expr TOKEN_R_BRACKET type {$$ = type_create_array(TYPE_ARRAY,0,$5,$3);}	
			| TOKEN_FUNCTION type TOKEN_L_PAREN param_list TOKEN_R_PAREN {$$ = type_create(TYPE_FUNCTION,$4,$2);}
			| TOKEN_VOID {$$ = type_create(TYPE_VOID,0,0);}
			;
param_list		: param_list_not_empty {$$ = $1;}
			| {$$ = 0;}
			;
param_list_not_empty	: param {$$ = $1;}
			| param TOKEN_COMMA param_list_not_empty {$$ = $1; $1->next = $3;}
			;
param			: ident TOKEN_COLON type {$$ = param_list_create($1,$3,0);}
			;
stmt_list		: stmt stmt_list {$$ = $1; $1->next = $2;}
			| {$$ = 0;}
			;
stmt			: stmt_matched {$$ = $1;}
			| stmt_unmatched {$$ = $1;}
			;
stmt_matched		: decl {$$ = stmt_create(STMT_DECL,$1,0,0,0,0,0);}
			| expr TOKEN_SEMICOLON {$$ = stmt_create(STMT_EXPR,0,0,$1,0,0,0);}
			| TOKEN_FOR TOKEN_L_PAREN opt_expr TOKEN_SEMICOLON opt_expr TOKEN_SEMICOLON opt_expr TOKEN_R_PAREN stmt_matched {$$ = stmt_create(STMT_FOR,0,$3,$5,$7,$9,0);}
			| stmt_block {$$ = $1;}
			| TOKEN_IF TOKEN_L_PAREN expr TOKEN_R_PAREN stmt_matched TOKEN_ELSE stmt_matched {$$ = stmt_create(STMT_IF_ELSE,0,0,$3,0,$5,$7);}
			| TOKEN_RETURN opt_expr TOKEN_SEMICOLON {$$ = stmt_create(STMT_RETURN,0,0,$2,0,0,0);}
			| TOKEN_PRINT expr_list TOKEN_SEMICOLON {$$ = stmt_create(STMT_PRINT,0,0,$2,0,0,0);}
			;
stmt_block		: TOKEN_L_BRACE stmt_list TOKEN_R_BRACE {$$ = stmt_create(STMT_BLOCK,0,0,0,0,$2,0);}
			;
stmt_unmatched		: TOKEN_IF TOKEN_L_PAREN expr TOKEN_R_PAREN stmt {$$ = stmt_create(STMT_IF_ELSE,0,0,$3,0,$5,0);}
			| TOKEN_IF TOKEN_L_PAREN expr TOKEN_R_PAREN stmt_matched TOKEN_ELSE stmt_unmatched {$$ = stmt_create(STMT_IF_ELSE,0,0,$3,0,$5,$7);}
			| TOKEN_FOR TOKEN_L_PAREN opt_expr TOKEN_SEMICOLON opt_expr TOKEN_SEMICOLON opt_expr TOKEN_R_PAREN stmt_unmatched {$$ = stmt_create(STMT_FOR,0,$3,$5,$7,$9,0);}
			;
expr			: expr_no_assign TOKEN_ASSIGN expr {$$ = expr_create(EXPR_ASSIGN,$1,$3);}
			| expr_no_assign {$$ = $1;}
expr_no_assign		: expr_no_assign TOKEN_OR expr_no_or {$$ = expr_create(EXPR_OR,$1,$3);}
			| expr_no_or {$$ = $1;}
			;
expr_no_or		: expr_no_or TOKEN_AND expr_no_and {$$ = expr_create(EXPR_AND,$1,$3);}
			| expr_no_and {$$ = $1;}
			;
expr_no_and		: expr_no_and TOKEN_LT expr_no_cmp {$$ = expr_create(EXPR_LT,$1,$3);}
			| expr_no_and TOKEN_GT expr_no_cmp {$$ = expr_create(EXPR_GT,$1,$3);}
			| expr_no_and TOKEN_LE expr_no_cmp {$$ = expr_create(EXPR_LE,$1,$3);}
			| expr_no_and TOKEN_GE expr_no_cmp {$$ = expr_create(EXPR_GE,$1,$3);}
			| expr_no_and TOKEN_EQ expr_no_cmp {$$ = expr_create(EXPR_EQ,$1,$3);}
			| expr_no_and TOKEN_NE expr_no_cmp {$$ = expr_create(EXPR_NE,$1,$3);}
			| expr_no_cmp {$$ = $1;}
			;
expr_no_cmp		: expr_no_cmp TOKEN_ADD expr_no_arith {$$ = expr_create(EXPR_ADD,$1,$3);}
			| expr_no_cmp TOKEN_SUB expr_no_arith {$$ = expr_create(EXPR_SUB,$1,$3);}
			| expr_no_arith {$$ = $1;}
			;
expr_no_arith		: expr_no_arith TOKEN_MUL expr_no_geo {$$ = expr_create(EXPR_MUL,$1,$3);}
			| expr_no_arith TOKEN_DIV expr_no_geo {$$ = expr_create(EXPR_DIV,$1,$3);}
			| expr_no_arith TOKEN_MOD expr_no_geo {$$ = expr_create(EXPR_MOD,$1,$3);}
			| expr_no_geo {$$ = $1;}
			;
expr_no_geo		: expr_no_geo TOKEN_EXP expr_no_exp {$$ = expr_create(EXPR_EXP,$1,$3);}
			| expr_no_exp {$$ = $1;}
			;
expr_no_exp		: TOKEN_SUB expr_no_exp {$$ = expr_create(EXPR_NEG,0,$2);}
			| TOKEN_LOGICAL_NOT expr_no_exp {$$ = expr_create(EXPR_NOT,0,$2);}
			| expr_no_unary {$$ = $1;}
			;
expr_no_unary		: expr_group TOKEN_INCREMENT {$$ = expr_create(EXPR_INCR,$1,0);}
			| expr_group TOKEN_DECREMENT {$$ = expr_create(EXPR_DECR,$1,0);}
			| expr_group {$$ = $1;}
			;
expr_group		: ident TOKEN_L_PAREN expr_list TOKEN_R_PAREN {$$ = expr_create(EXPR_FUNC,expr_create_name($1),$3);}
			| ident TOKEN_L_BRACKET expr TOKEN_R_BRACKET /*expr_array_list*/ {$$ = expr_create(EXPR_ARRAY,expr_create_name($1),$3/*expr_create(EXPR_ARRAY_LIST,$3,$5)*/);}
			| TOKEN_L_PAREN expr TOKEN_R_PAREN {$$ = expr_create(EXPR_GROUP,$2,0);}	// ()
			| expr_primary {$$ = $1;}
			;
expr_primary		: ident {$$ = expr_create_name($1);}
			| TOKEN_INTEGER_LITERAL {$$ = expr_create_integer_literal(atoi(yytext));}
			| TOKEN_STRING_LITERAL {char *buf; buf = strdup(yytext); $$ = expr_create_string_literal(buf);}
			| TOKEN_CHARACTER_LITERAL {$$ = expr_create_character_literal(yytext[0]);}
			| TOKEN_TRUE {$$ = expr_create_boolean_literal(1);}
			| TOKEN_FALSE {$$ = expr_create_boolean_literal(0);}
			;
expr_block		: TOKEN_L_BRACE expr_list_not_empty_b TOKEN_R_BRACE {$$ = expr_create(EXPR_BLOCK,$2,0);}
			;
opt_expr		: expr {$$ = $1;}
			| {$$ = 0;}
			;
expr_list		: expr_list_not_empty {$$ = $1;}
			| {$$ = 0;}
			;
expr_list_not_empty_b	: expr_block TOKEN_COMMA expr_list_not_empty_b {$$ = expr_create(EXPR_BLOCK,$1,$3);}
			| expr_block {$$ = $1;}
			| expr_list_not_empty {$$ = expr_create(EXPR_BLOCK,$1,0);}
			;
expr_list_not_empty	: expr {$$ = $1;}	
			| expr TOKEN_COMMA expr_list_not_empty {$$ = expr_create(EXPR_LIST,$1,$3);}	
			;
ident			: TOKEN_IDENT {char *buf=0; buf = strdup(yytext); $$ = buf;}
			;

%%

int yyerror(char *str)
{
	fprintf(stderr,"parse error: %s\n",str);
	return 0;
}
